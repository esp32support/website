<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>About the Project - ESP32 CAN Sniffer</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect x='20' y='20' width='60' height='60' fill='%237dd3fc' stroke='%23bae6fd' stroke-width='2' rx='4'/%3E%3Crect x='25' y='25' width='50' height='50' fill='%23080a10'/%3E%3Ccircle cx='20' cy='35' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='20' cy='50' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='20' cy='65' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='80' cy='35' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='80' cy='50' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='80' cy='65' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='35' cy='20' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='50' cy='20' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='65' cy='20' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='35' cy='80' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='50' cy='80' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='65' cy='80' r='2' fill='%237dd3fc'/%3E%3C/svg%3E" />
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect x='20' y='20' width='60' height='60' fill='%237dd3fc' stroke='%23bae6fd' stroke-width='2' rx='4'/%3E%3Crect x='25' y='25' width='50' height='50' fill='%23080a10'/%3E%3Ccircle cx='20' cy='35' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='20' cy='50' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='20' cy='65' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='80' cy='35' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='80' cy='50' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='80' cy='65' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='35' cy='20' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='50' cy='20' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='65' cy='20' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='35' cy='80' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='50' cy='80' r='2' fill='%237dd3fc'/%3E%3Ccircle cx='65' cy='80' r='2' fill='%237dd3fc'/%3E%3C/svg%3E" />
    <link rel="stylesheet" href="../styles.css">
    <link rel="stylesheet" href="../cookie-consent.css">
    
    <!-- Google Analytics - Only loads if user accepts cookies -->
    <script>
        window.gaId = 'G-6KFL6RX1SM'; // ‚úÖ Google Analytics ID
    </script>
    <style>
        body {
            background-color: #080a10;
            color: #e5e9f0;
        }
        .about-content {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
            background-color: transparent;
            color: #e5e9f0;
        }
        .about-content h1 {
            color: #e5e9f0;
            border-bottom: 3px solid #7dd3fc;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        .about-content h2 {
            color: #e5e9f0;
            margin-top: 40px;
            margin-bottom: 20px;
            padding-left: 10px;
            border-left: 4px solid #7dd3fc;
        }
        .about-content p {
            line-height: 1.8;
            color: #e5e9f0;
            margin: 15px 0;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #7dd3fc;
            text-decoration: none;
        }
        .back-link:hover {
            text-decoration: underline;
            color: #bae6fd;
        }
        .highlight-box {
            background: rgba(125, 211, 252, 0.1);
            border-left: 4px solid #7dd3fc;
            padding: 20px;
            margin: 25px 0;
            border-radius: 5px;
            color: #e5e9f0;
        }
        .timeline {
            margin: 30px 0;
        }
        .timeline-item {
            margin: 25px 0;
            padding-left: 30px;
            position: relative;
            color: #e5e9f0;
        }
        .timeline-item::before {
            content: "‚óè";
            position: absolute;
            left: 0;
            color: #7dd3fc;
            font-size: 1.5em;
        }
        .mission-box {
            background: rgba(125, 211, 252, 0.1);
            border: 2px solid #7dd3fc;
            border-radius: 8px;
            padding: 25px;
            margin: 30px 0;
            color: #e5e9f0;
        }
        .mission-box h3 {
            color: #e5e9f0;
            margin-top: 0;
        }
        .about-content ul, .about-content li {
            color: #e5e9f0;
        }
        .about-content a {
            color: #7dd3fc;
        }
        .about-content a:hover {
            color: #bae6fd;
        }
        
        /* Responsive Design */
        @media (max-width: 768px) {
            .about-content {
                padding: 20px 15px;
            }
            
            .about-content h1 {
                font-size: clamp(1.5rem, 6vw, 2rem);
            }
            
            .about-content h2 {
                font-size: clamp(1.3rem, 5vw, 1.7rem);
                margin-top: 30px;
            }
            
            .about-content p {
                font-size: 0.95rem;
                line-height: 1.7;
            }
            
            .highlight-box, .mission-box {
                padding: 15px;
                margin: 20px 0;
            }
            
            .timeline-item {
                margin: 20px 0;
                padding-left: 25px;
            }
        }
        
        @media (max-width: 480px) {
            .about-content {
                padding: 15px 10px;
            }
            
            .about-content ul {
                padding-left: 20px;
            }
            
            .highlight-box, .mission-box {
                padding: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="about-content">
        <h1>About the Project</h1>
        
        <h2>üéØ How and Why This Project Started</h2>
        
        <p>
            The ESP32 CAN Sniffer project was born out of a real-world need for accessible, affordable, and powerful CAN bus analysis tools. 
            Traditional CAN bus analyzers are often expensive, proprietary, and complex, making them inaccessible to hobbyists, students, and 
            independent mechanics.
        </p>
        
        <div class="highlight-box">
            <p>
                <strong>The Vision:</strong> Create a professional-grade CAN bus sniffer that combines the power of modern hardware (ESP32) 
                with an intuitive, feature-rich software interface, all at a fraction of the cost of commercial solutions.
            </p>
        </div>
        
        <h2>üí° The Inspiration</h2>
        
        <p>
            Working with vehicle diagnostics and CAN bus communication, we encountered several challenges:
        </p>
        
        <ul>
            <li><strong>High Cost:</strong> Professional CAN analyzers can cost hundreds or thousands of euros</li>
            <li><strong>Limited Flexibility:</strong> Many tools are locked to specific protocols or vehicle brands</li>
            <li><strong>Complex Interfaces:</strong> Enterprise tools often have steep learning curves</li>
            <li><strong>Proprietary Formats:</strong> Data export and analysis options are often limited</li>
            <li><strong>Custom Hardware Requirements:</strong> Many solutions require custom PCB designs and specialized manufacturing</li>
        </ul>
        
        <p>
            We realized that with modern hardware like the ESP32 and open-source software, we could create a solution that addresses all 
            these pain points while maintaining professional-grade functionality. A key inspiration was the idea to use readily available, 
            off-the-shelf hardware components (ESP32 development boards and MCP2515 CAN controller modules) without needing to design and 
            manufacture custom PCBs. This approach makes the project accessible to anyone who can purchase standard components online, 
            significantly lowering the barrier to entry and reducing costs.
        </p>
        
        <h2>üöÄ The Journey</h2>
        
        <div class="timeline">
            <div class="timeline-item">
                <strong>Initial Concept</strong><br>
                The project started with a simple idea: use an ESP32 microcontroller with a CAN controller (MCP2515) to capture CAN bus 
                traffic and display it on a computer. The ESP32's built-in WiFi and USB capabilities made it perfect for flexible connectivity.
            </div>
            
            <div class="timeline-item">
                <strong>Hardware Integration</strong><br>
                We designed and tested the hardware setup using readily available, off-the-shelf components‚Äîno custom PCB designs required. 
                The solution uses standard ESP32 development boards and MCP2515 CAN controller modules that can be purchased from any 
                electronics supplier. We ensured reliable SPI communication between ESP32 and MCP2515, proper power management, and robust 
                CAN bus connectivity. The pinout was carefully chosen to work with standard ESP32 development boards, making it easy for 
                anyone to assemble the hardware with just basic soldering skills or even jumper wires for prototyping.
            </div>
            
            <div class="timeline-item">
                <strong>Software Development</strong><br>
                Building a modern, user-friendly GUI was crucial. We chose PyQt5 for its cross-platform capabilities and professional 
                appearance. The software evolved to include real-time message capture, advanced filtering, session management, and 
                vehicle-specific decoding (starting with Fiat vehicles).
            </div>
            
            <div class="timeline-item">
                <strong>Performance Optimization</strong><br>
                As the project grew, performance became critical. We implemented high-performance buffering, optimized serial communication, 
                and added performance tuning options. The system can now handle hundreds of messages per second reliably.
            </div>
            
            <div class="timeline-item">
                <strong>Feature Expansion</strong><br>
                Additional features were added based on real-world needs: WiFi connectivity for remote monitoring, session replay, CSV export, 
                custom labeling, dark/light themes, and comprehensive error handling. Each feature was designed with usability in mind.
            </div>
            
            <div class="timeline-item">
                <strong>Production Ready</strong><br>
                After extensive testing, bug fixes, and refinement, the project reached production quality. We implemented licensing, 
                crash handling, bug reporting, and comprehensive documentation to ensure a professional user experience.
            </div>
        </div>
        
        <h2>üéØ Project Goals</h2>
        
        <div class="mission-box">
            <h3>Our Mission</h3>
            <p>
                To democratize CAN bus analysis by providing a powerful, affordable, and accessible tool that empowers users to understand 
                and work with vehicle communication systems, whether for diagnostics, reverse engineering, education, or hobby projects.
            </p>
        </div>
        
        <p><strong>Key Objectives:</strong></p>
        <ul>
            <li><strong>Accessibility:</strong> Make professional CAN bus analysis available to everyone, not just professionals with expensive tools</li>
            <li><strong>Usability:</strong> Create an intuitive interface that doesn't require extensive training</li>
            <li><strong>Flexibility:</strong> Support multiple connection methods (USB Serial and WiFi) and various use cases</li>
            <li><strong>Reliability:</strong> Ensure stable operation even under high message rates and long capture sessions</li>
            <li><strong>Extensibility:</strong> Provide a foundation that can be extended with custom decoders and features</li>
            <li><strong>Documentation:</strong> Comprehensive guides and resources to help users succeed</li>
        </ul>
        
        <h2>üîß Technical Philosophy</h2>
        
        <p>
            This project follows several key principles:
        </p>
        
        <ul>
            <li><strong>Open Architecture:</strong> Modular design allows for easy extension and customization</li>
            <li><strong>Performance First:</strong> Optimized for real-time operation with minimal latency</li>
            <li><strong>Error Resilience:</strong> Robust error handling ensures the application continues working even when issues occur</li>
            <li><strong>User-Centric:</strong> Every feature is designed with the end user's workflow in mind</li>
            <li><strong>Quality Code:</strong> Clean, maintainable code with comprehensive testing</li>
        </ul>
        
        <h2>üåç Impact and Future</h2>
        
        <p>
            The ESP32 CAN Sniffer has the potential to:
        </p>
        
        <ul>
            <li>Enable independent mechanics and hobbyists to diagnose vehicle issues</li>
            <li>Support educational institutions teaching automotive electronics and CAN bus protocols</li>
            <li>Help researchers and developers working on vehicle communication systems</li>
            <li>Provide a foundation for custom vehicle monitoring and automation projects</li>
            <li>Lower the barrier to entry for CAN bus analysis and reverse engineering</li>
        </ul>
        
        <p>
            As the project continues to evolve, we're committed to maintaining high quality, adding new features based on user feedback, 
            and supporting the community of users who rely on this tool.
        </p>
        
        <h2>üôè Acknowledgments</h2>
        
        <p>
            This project builds upon the work of the open-source community, including:
        </p>
        
        <ul>
            <li>The ESP32 development community and Espressif Systems</li>
            <li>PyQt5 and Qt framework developers</li>
            <li>The Python open-source ecosystem</li>
            <li>All contributors and testers who provided feedback and improvements</li>
        </ul>
        
        <div style="margin-top: 50px; padding-top: 20px; border-top: 1px solid #ddd; color: #777; font-size: 0.9em;">
            <p>For questions, feedback, or support, contact: <a href="mailto:esp32contact@gmail.com">esp32contact@gmail.com</a></p>
        </div>
        
        <div style="margin-top: 3rem; text-align: center;">
            <a href="../index.html" class="btn outline" style="display: inline-block;">Back to Home</a>
        </div>
    </div>
    
    <!-- Statistics Tracking (Internal Use Only) -->
    <script src="../analytics.js"></script>
    
    <!-- Cookie Consent (GDPR Compliant) -->
    <script src="../cookie-consent.js"></script>
</body>
</html>

